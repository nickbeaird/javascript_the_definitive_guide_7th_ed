# Ch3 - Types, Values, and Variables

## 3.1 Overview
- Most everything is an object
- There are mutables (arrays and objects) and immutable objects (Strings, NaN, Infinity)

## 3.2 Numbers
- Numbers are immutable
- Numbers can be integers or decimals (floats in Python)
- Numbers can be hexidecimal
```javascript
0xff       // => 255: (15*16 + 15)
```
- Numbers can be in binary
```javascript
0b10101  // => 21:  (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
```

## 3.3 Floating Points
- Floating point literals are type number
```javascript
> typeof(3.14)
'number'
>
```
- You can use e-notation for power of 10
```javascript
6.02e23        // 6.02 × 10²³
```
- As of ECMA6 (2020) you can use underscore for commas in numbers
```javascript
let one_million = 1_000_000
```
- You can use the Math library (a core JS library) for working with numbers
```javascript
Math.pow(10, 2) // 100 (10 * 10)
Math.floor(.7)  // 0.0 
```
- Division by 0 gives an infinity
```javascript
> 1/0
Infinity
```
- Any value that is not defined, or most likely any value that is not being caught correctly will reult in a undefined as see 

- There are multiple ways to call NaN (not a number)
```javascript
> 0/0
NaN
> NaN
NaN
> Number.NaN
NaN
```

- JS has the concept of a BigInt as of ES2020. It is of a new type. These are numbers, but are too large for the 32bit representation of earlier versions of JS. This is 64bit.
- The BigInt function can convert strings or numbers to BigInt
```javascript
BigInt(Number.MAX_SAFE_INTEGER)     // => 9007199254740991n
```
- A BigInt is a string followed by an 'n'.
- BigInt numbers work like any other Number class, but it drops any remainder and rounds down.
- BigInts look a lot like Integers in Python, IMHO. 


## 3.2.6 Dates and Times
- JS has a date class
- You can create a date object, or call the values generated by the Date Class. 
```javascript
> let nowish = new Date();
undefined
> nowish
2020-03-22T05:33:05.116Z

> let no_really_now = Date.now()
undefined
> no_really_now
1584855208229
```

## 3.3 Text
- Strings are immutable
- Strings are a sequence of 16bit characters. UTF-16
- Strings use zero based indexes
```javascript
> let new_string = "Hello"
undefined
> new_string[3]
'l'
```
- Strings have methods
```javascript
> new_string.length
5
```

## 3.3.1 String Literals
- You can make string literals with backticks
```javascript
> let name = "Nick"
undefined
> `Once upon a time a mediocre looking prince named ${ name }`
'Once upon a time a mediocre looking prince named Nick'
```

## 3.3.2 Escape Sequences
- Use the '\' for escape sequences

## 3.3.3 Working with Strings 
- You can concatentate strings with the + operator
- You can compare string values
- There are plenty of methods to call on a string object. 

## 3.3.4 Template Literals 
- String literals can be created with a backtick `
- JavaScript can be called between the $ { function } in a Template Literal. Everything in the brackets is a JavaScript expression. 
- Tagged Template Literals 
    -  Will come back to these. There is a lot of ability to pass all values from Template literal values computed to a function using something akin to *args and **kwargs in Python. 

## 3.3.5 Pattern Matching
- We can easily use regex with strings. 
- There are built in methods for Strings to call regex on. 
```javascript
let name = "new test: 1, Nicky B Ballin'"
let pattern = /\d/g
pattern.test(name)
```
- Takeaway: Practice my regex skills. They are absolutely mandatory in JavaScript.


## 3.4 Boolean Values
- Booleans are called control structures. 
- Any JS value can be converted to a boolean value. 
- You can do a similar thing as in Python for if an object exists. 
```python
a = 'test'(
if a:
    print('Woot!')  # 'Woot'
```
```javascript
let a = 'test'
if (a) {
    console.log('js woot')  // 'js woot'
}
```

## 3.5 null and undefined
